#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QListWidget>
#include <QLabel>
#include <QPushButton>
#include <QComboBox>
#include "soldierdialog.h"

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void addSoldier();
    void showOldestByRank();

private:
    QListWidget *soldierList;
    QLabel *companyLogo;
    QPushButton *addSoldierButton;
    QPushButton *oldestByRankButton;
    QComboBox *rankComboBox;

    void setupUI();
};

#endif // MAINWINDOW_H

#include "mainwindow.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QPixmap>
#include <QDir>
#include <QMessageBox>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    setupUI();
}

MainWindow::~MainWindow()
{
}

void MainWindow::setupUI()
{
    soldierList = new QListWidget(this);
    companyLogo = new QLabel(this);
    addSoldierButton = new QPushButton("Add Soldier", this);
    oldestByRankButton = new QPushButton("Oldest by Rank", this);
    rankComboBox = new QComboBox(this);
    rankComboBox->addItem("Private");
    rankComboBox->addItem("Sergeant");
    rankComboBox->addItem("Captain");

    // Load company logo
    QString imagePath = QDir::currentPath() + "/company_logo.png";
    QPixmap logo(imagePath);
    companyLogo->setPixmap(logo.scaled(150, 150));

    QHBoxLayout *mainLayout = new QHBoxLayout;
    QVBoxLayout *buttonLayout = new QVBoxLayout;
    buttonLayout->addWidget(addSoldierButton);
    buttonLayout->addWidget(oldestByRankButton);
    buttonLayout->addWidget(rankComboBox);
    mainLayout->addWidget(soldierList);
    mainLayout->addWidget(companyLogo);
    mainLayout->addLayout(buttonLayout);

    QWidget *centralWidget = new QWidget(this);
    centralWidget->setLayout(mainLayout);
    setCentralWidget(centralWidget);

    connect(addSoldierButton, SIGNAL(clicked()), this, SLOT(addSoldier()));
    connect(oldestByRankButton, SIGNAL(clicked()), this, SLOT(showOldestByRank()));
}

void MainWindow::addSoldier()
{
    SoldierDialog dialog(this);

    if (dialog.exec() == QDialog::Accepted) {
        QString name = dialog.getName();
        int age = dialog.getAge();
        QString rank = dialog.getRank();

        if (age <= 18) {
            QMessageBox::critical(this, "Error", "Soldier must be at least 18 years old.");
            return;
        }

        // Add soldier to the list
        QString soldierInfo = name + ", " + rank + ", " + QString::number(age);
        soldierList->addItem(soldierInfo);

        // Sort the list by age (oldest first)
        for (int i = 0; i < soldierList->count() - 1; ++i) {
            for (int j = i + 1; j < soldierList->count(); ++j) {
                QStringList soldier1 = soldierList->item(i)->text().split(", ");
                QStringList soldier2 = soldierList->item(j)->text().split(", ");
                if (soldier1[2].toInt() < soldier2[2].toInt()) {
                    soldierList->swapItems(i, j);
                }
            }
        }
    }
}

void MainWindow::showOldestByRank()
{
    QString selectedRank = rankComboBox->currentText();
    int index = -1;

    // Find the oldest soldier of the selected rank
    for (int i = 0; i < soldierList->count(); ++i) {
        QStringList soldierInfo = soldierList->item(i)->text().split(", ");
        if (soldierInfo[1] == selectedRank) {
            if (index == -1 || soldierInfo[2].toInt() > soldierList->item(index)->text().split(", ")[2].toInt()) {
                index = i;
            }
        }
    }

    if (index != -1) {
        QMessageBox::information(this, "Oldest Soldier by Rank", soldierList->item(index)->text());
    } else {
        QMessageBox::information(this, "Oldest Soldier by Rank", "No soldier of selected rank found.");
    }
}

#ifndef SOLDIERDIALOG_H
#define SOLDIERDIALOG_H

#include <QDialog>
#include <QLineEdit>
#include <QSpinBox>
#include <QComboBox>
#include <QPushButton>

class SoldierDialog : public QDialog
{
    Q_OBJECT

public:
    SoldierDialog(QWidget *parent = nullptr);
    ~SoldierDialog();

    QString getName() const;
    int getAge() const;
    QString getRank() const;

private:
    QLineEdit *nameLineEdit;
    QSpinBox *ageSpinBox;
    QComboBox *rankComboBox;
    QPushButton *okButton;
    QPushButton *cancelButton;

    void setupUI();
};

#endif // SOLDIERDIALOG

#include "soldierdialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>

SoldierDialog::SoldierDialog(QWidget *parent)
    : QDialog(parent)
{
    setupUI();
}

SoldierDialog::~SoldierDialog()
{
}

void SoldierDialog::setupUI()
{
    nameLineEdit = new QLineEdit(this);
    ageSpinBox = new QSpinBox(this);
    rankComboBox = new QComboBox(this);
    okButton = new QPushButton("OK", this);
    cancelButton = new QPushButton("Cancel", this);

    ageSpinBox->setMinimum(18);
    rankComboBox->addItem("Private");
    rankComboBox->addItem("Sergeant");
    rankComboBox->addItem("Captain");

    QVBoxLayout *mainLayout = new QVBoxLayout;
    mainLayout->addWidget(new QLabel("Name:", this));
    mainLayout->addWidget(nameLineEdit);
    mainLayout->addWidget(new QLabel("Age:", this));
    mainLayout->addWidget(ageSpinBox);
    mainLayout->addWidget(new QLabel("Rank:", this));
    mainLayout->addWidget(rankComboBox);

    QHBoxLayout *buttonLayout = new QHBoxLayout;
    buttonLayout->addWidget(okButton);
    buttonLayout->addWidget(cancelButton);

    mainLayout->addLayout(buttonLayout);

    connect(okButton, SIGNAL(clicked()), this, SLOT(accept()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));

    setLayout(mainLayout);
}

QString SoldierDialog::getName() const
{
    return nameLineEdit->text();
}

int SoldierDialog::getAge() const
{
    return ageSpinBox->value();
}

QString SoldierDialog::getRank() const
{
    return rankComboBox->currentText();
}

void MainWindow::addSoldier()
{
    SoldierDialog dialog(this);

    if (dialog.exec() == QDialog::Accepted) {
        QString name = dialog.getName();
        int age = dialog.getAge();
        QString rank = dialog.getRank();

        if (age <= 18) {
            QMessageBox::critical(this, "Error", "Soldier must be at least 18 years old.");
            return;
        }

        // Add soldier to the list
        QString soldierInfo = name + ", " + rank + ", " + QString::number(age);
        QListWidgetItem *newSoldier = new QListWidgetItem(soldierInfo);
        soldierList->addItem(newSoldier);

        // Sort the list by age (oldest first)
        for (int i = 0; i < soldierList->count() - 1; ++i) {
            for (int j = i + 1; j < soldierList->count(); ++j) {
                QStringList soldier1 = soldierList->item(i)->text().split(", ");
                QStringList soldier2 = soldierList->item(j)->text().split(", ");
                if (soldier1[2].toInt() < soldier2[2].toInt()) {
                    soldierList->insertItem(i, soldierList->takeItem(j));
                }
            }
        }
    }
}



zad1
// zbior.h
#pragma once

class Zbior
{
    size_t m_liczbaElementow = 0;
    double* m_elementy = nullptr;
    double m_dolnaGranica = 0;
    double m_gornaGranica = 0;

    void alokuj(int);
    void zwolnij();
    void kopiuj(const Zbior& other);

public:
    Zbior(size_t liczElem, double dGran, double gGran);
    Zbior(const Zbior& other);
    Zbior(Zbior&& other) noexcept;
    Zbior& operator=(const Zbior& other);
    Zbior& operator=(Zbior&& other) noexcept;
    ~Zbior();

    // Inne metody klasy...
};

// zbior.cpp
#include "zbior.h"
#include <new>
#include <algorithm>

// ... (pozostała część klasy)

// Konstruktor kopiujący
Zbior::Zbior(const Zbior& other)
{
    kopiuj(other);
}

// Konstruktor przenoszący
Zbior::Zbior(Zbior&& other) noexcept
    : m_liczbaElementow(other.m_liczbaElementow),
      m_elementy(other.m_elementy),
      m_dolnaGranica(other.m_dolnaGranica),
      m_gornaGranica(other.m_gornaGranica)
{
    other.m_liczbaElementow = 0;
    other.m_elementy = nullptr;
    other.m_dolnaGranica = 0;
    other.m_gornaGranica = 0;
}

// Operator przypisania kopiujący
Zbior& Zbior::operator=(const Zbior& other)
{
    if (this != &other)
    {
        zwolnij();
        kopiuj(other);
    }
    return *this;
}

// Operator przypisania przenoszący
Zbior& Zbior::operator=(Zbior&& other) noexcept
{
    if (this != &other)
    {
        zwolnij();
        m_liczbaElementow = other.m_liczbaElementow;
        m_elementy = other.m_elementy;
        m_dolnaGranica = other.m_dolnaGranica;
        m_gornaGranica = other.m_gornaGranica;

        other.m_liczbaElementow = 0;
        other.m_elementy = nullptr;
        other.m_dolnaGranica = 0;
        other.m_gornaGranica = 0;
    }
    return *this;
}

// Inne metody klasy...

// zbior.h
#pragma once

#include <vector>

class Zbior
{
    // ... (reszta klasy)

public:
    // Inne metody klasy...

    operator double() const;
    double mediana() const;
};

// zbior.cpp
#include "zbior.h"
#include <algorithm>

// ... (pozostała część klasy)

// Konwersja do typu double
Zbior::operator double() const
{
    double suma = 0.0;
    for (size_t i = 0; i < m_liczbaElementow; ++i)
    {
        suma += m_elementy[i];
    }
    return suma / m_liczbaElementow;
}

// Obliczanie mediany
double Zbior::mediana() const
{
    if (m_liczbaElementow == 0)
        return 0.0;

    std::vector<double> kopija(m_elementy, m_elementy + m_liczbaElementow);
    std::sort(kopija.begin(), kopija.end());

    if (m_liczbaElementow % 2 == 0)
    {
        size_t srodek1 = m_liczbaElementow / 2 - 1;
        size_t srodek2 = m_liczbaElementow / 2;
        return (kopija[srodek1] + kopija[srodek2]) / 2.0;
    }
    else
    {
        size_t srodek = m_liczbaElementow / 2;
        return kopija[srodek];
    }
}

#include "zbior.h"
#include <vector>
#include <iostream>

int main()
{
    std::vector<double> wektor;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> rozklad(1.0, 10.0);

    for (int i = 0; i < 10; ++i)
    {
        Zbior zbior(5, 1.0, 10.0);
        wektor.push_back(static_cast<double>(zbior));
    }

// zbior.h
#include <cmath>
#include <algorithm>

class Zbior
{
    // ... (reszta klasy)

public:
    // Inne metody klasy...

    class ZbiorFunctor
    {
        const std::vector<double>& wektor;
        double tolerancja;

    public:
        ZbiorFunctor(const std::vector<double>& w, double t = 1e-3) : wektor(w), tolerancja(t) {}

        bool operator()(double arg) const
        {
            return std::none_of(wektor.begin(), wektor.end(), [=](double elem) {
                return std::abs(arg - elem) <= tolerancja;
            });
        }
    };
};



// zbior.cpp
#include "zbior.h"
#include <iostream>

// ... (pozostała część klasy)

// W definicji klasy Zbior:

double Zbior::mediana() const
{
    // ... (poprzednia implementacja)
}

// Implementacja main dla punktu 3:

int main()
{
    std::vector<double> wektor;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> rozklad(1.0, 10.0);

    for (int i = 0; i < 10; ++i)
    {
        Zbior zbior(5, 1.0, 10.0);
        wektor.push_back(static_cast<double>(zbior));
    }

    // Implementacja funktora:

    Zbior::ZbiorFunctor funktor(wektor);

    // Przykład użycia funktora z funkcją z biblioteki <algorithm>:

    auto it = std::find_if_not(wektor.begin(), wektor.end(), funktor);

    if (it != wektor.end())
    {
        std::cout << "Znaleziono element istotnie różny od zbioru.\n";
    }
    else
    {
        std::cout << "Nie znaleziono elementu istotnie różnego od zbioru.\n";
    }

    return 0;
}

// zbior.h
#include <cmath>
#include <algorithm>

class Zbior
{
    // ... (reszta klasy)

public:
    // Inne metody klasy...

    class ZbiorFunctor
    {
        const std::vector<double>& wektor;
        double tolerancja;

    public:
        ZbiorFunctor(const std::vector<double>& w, double t = 1e-3) : wektor(w), tolerancja(t) {}

        bool operator()(double arg) const
        {
            return std::none_of(wektor.begin(), wektor.end(), [=](double elem) {
                return std::abs(arg - elem) <= tolerancja;
            });
        }
    };
};


// zbior.cpp
#include "zbior.h"
#include <iostream>
#include <algorithm>

// ... (pozostała część klasy)

// W definicji klasy Zbior:

double Zbior::mediana() const
{
    // ... (poprzednia implementacja)
}

// Implementacja main dla punktu 3:

int main()
{
    std::vector<double> wektor;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> rozklad(1.0, 10.0);

    for (int i = 0; i < 10; ++i)
    {
        Zbior zbior(5, 1.0, 10.0);
        wektor.push_back(static_cast<double>(zbior));
    }

    // Implementacja funktora:

    Zbior::ZbiorFunctor funktor(wektor);

    // Przykład użycia funktora z funkcją z biblioteki <algorithm>:

    auto it = std::find_if_not(wektor.begin(), wektor.end(), funktor);

    if (it != wektor.end())
    {
        std::cout << "Znaleziono element istotnie różny od zbioru.\n";
    }
    else
    {
        std::cout << "Nie znaleziono elementu istotnie różnego od zbioru.\n";
    }

    return 0;
}

Ważność	Kod	Opis	Projekt	Plik	Wiersz	Stan pominięcia
Błąd (aktywny)	E0289	żadne wystąpienie konstruktora "Zbior::ZbiorFunctor::ZbiorFunctor" nie jest zgodne z listą argumentów	Project1	C:\Users\student\Desktop\kolt1dk\Project1\zbior.cpp	145	


// zbior.h
#pragma once
#include <vector>
#include <algorithm>
#include <cmath>

class Zbior
{
    size_t m_liczbaElementow = 0;
    double* m_elementy = nullptr;
    double m_dolnaGranica = 0;
    double m_gornaGranica = 0;
    void alokuj(int);
    void zwolnij();

public:
    Zbior(size_t liczElem, double dGran, double gGran);
    Zbior(const Zbior& other);
    Zbior(Zbior&& other) noexcept;
    Zbior& operator=(const Zbior& other);
    Zbior& operator=(Zbior&& other) noexcept;
    ~Zbior();

    operator double() const;

    // Dodatkowe metody, takie jak obliczanie mediany, mogą być dodane tu.

    friend class RoznyOdElementow;
};

class RoznyOdElementow
{
public:
    RoznyOdElementow(const std::vector<double>& elements, double tolerance = 1e-3)
        : m_elements(elements), m_tolerance(tolerance) {}

    bool operator()(double value) const
    {
        for (double element : m_elements)
        {
            if (std::abs(value - element) < m_tolerance)
                return false;
        }
        return true;
    }

private:
    std::vector<double> m_elements;
    double m_tolerance;
};

// zbior.cpp
#include "zbior.h"
#include <new>
#include <random>

void Zbior::alokuj(int n)
{
    if (n > 0)
    {
        m_elementy = new(std::nothrow) double[n];
        m_liczbaElementow = n;
    }
}

void Zbior::zwolnij()
{
    if (m_elementy != nullptr)
    {
        delete[] m_elementy;
        m_elementy = nullptr;
    }
}

Zbior::Zbior(size_t liczElem, double dGran, double gGran)
{
    alokuj(liczElem);
    std::uniform_real_distribution<double> zakres(dGran, gGran);
    std::random_device generator;
    for (int elem = 0; elem < liczElem; elem++)
        m_elementy[elem] = zakres(generator);
}

Zbior::Zbior(const Zbior& other)
{
    alokuj(other.m_liczbaElementow);
    std::copy(other.m_elementy, other.m_elementy + m_liczbaElementow, m_elementy);
    m_dolnaGranica = other.m_dolnaGranica;
    m_gornaGranica = other.m_gornaGranica;
}

Zbior::Zbior(Zbior&& other) noexcept
{
    m_liczbaElementow = other.m_liczbaElementow;
    m_elementy = other.m_elementy;
    m_dolnaGranica = other.m_dolnaGranica;
    m_gornaGranica = other.m_gornaGranica;

    other.m_liczbaElementow = 0;
    other.m_elementy = nullptr;
    other.m_dolnaGranica = 0;
    other.m_gornaGranica = 0;
}

Zbior& Zbior::operator=(const Zbior& other)
{
    if (this != &other)
    {
        zwolnij();
        alokuj(other.m_liczbaElementow);
        std::copy(other.m_elementy, other.m_elementy + m_liczbaElementow, m_elementy);
        m_dolnaGranica = other.m_dolnaGranica;
        m_gornaGranica = other.m_gornaGranica;
    }
    return *this;
}

Zbior& Zbior::operator=(Zbior&& other) noexcept
{
    if (this != &other)
    {
        zwolnij();
        m_liczbaElementow = other.m_liczbaElementow;
        m_elementy = other.m_elementy;
        m_dolnaGranica = other.m_dolnaGranica;
        m_gornaGranica = other.m_gornaGranica;

        other.m_liczbaElementow = 0;
        other.m_elementy = nullptr;
        other.m_dolnaGranica = 0;
        other.m_gornaGranica = 0;
    }
    return *this;
}

Zbior::~Zbior()
{
    zwolnij();
}

Zbior::operator double() const
{
    std::vector<double> tempVec(m_elementy, m_elementy + m_liczbaElementow);
    std::sort(tempVec.begin(), tempVec.end());
    size_t middle = m_liczbaElementow / 2;
    return (m_liczbaElementow % 2 == 0) ? (tempVec[middle - 1] + tempVec[middle]) / 2.0 : tempVec[middle];
}

int main()
{
    std::vector<Zbior> zbiorVector;

    std::random_device generator;
    std::uniform_int_distribution<int> liczbaElementowDist(5, 10);
    std::uniform_real_distribution<double> granicaDist(1.0, 10.0);

    for (int i = 0; i < 5; ++i)
    {
        int liczbaElementow = liczbaElementowDist(generator);
        double dolnaGranica = granicaDist(generator);
        double gornaGranica = granicaDist(generator);

        Zbior nowyZbior(liczbaElementow, dolnaGranica, gornaGranica);
        zbiorVector.push_back(nowyZbior);
    }

    // Wyświetlenie mediany dla każdego zbioru w wektorze
    for (const auto& zbior : zbiorVector)
    {
        double median = static_cast<double>(zbior);
        std::cout << "Mediana zbioru: " << median << std::endl;
    }

    // Demonstracja funktora
    std::vector<double> innaKolekcja = {1.5, 2.0, 3.2, 4.8, 5.5};
    RoznyOdElementow roznyOdInnych(innaKolekcja);
    double testValue = 3.0;

    if (roznyOdInnych(testValue))
    {
        std::cout << testValue << " jest różne od elementów w innej kolekcji." << std::endl;
    }
    else
    {
        std::cout << testValue << " jest istotnie równe przynajmniej jednemu elementowi w innej kolekcji." << std::endl;
    }

    return 0;
}